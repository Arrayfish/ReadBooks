# Rustで学ぶWebAssemblyの読書録

## 第1章 プログラミング言語Rustの準備

飛ばした

## 第2章 WebAssemblyとは

WebAssembly(Wasm): プログラムを記述するためのポータブルなバイナリフォーマット

- Wasmはビルドターゲットであること: 色々な言語からWasmにコンパイル可能
- 作成元が信用できないコードも安全に実行できること: サンドボックスの中で実行することを想定している。
- バイナリーファイルをテキスト形式(WAT)に変換でき、ソースコードを読むことができること

マルチフォーマットなアプリケーションを作るときに、共通したロジックを利用できるので便利

wasmの標準化はW3Cで進められている。

### コンポーネントモデル

Wasmの仕様は構造をもつデータのデータ表現を定義していないので、複数のWasmモジュールを組み合わせることが難しかった。
データ表現以外にも、関数呼び出し規則、メモリー管理、例外処理、開発体験が問題になってきた。
これらを解決するためにコンポーネントモデルが提案された

コンポーネントモデルは以下の3つの仕様を取りまとめる

- Application Binary Interface(ABI)
- インターフェース定義言語(IDL)
- バイナリーフォーマット

## 第3章 RustによるWebAssembly作成入門

Wasmコンポーネントは大きくは次の2種類

- コマンドラインアプリケーションとして実行可能なもの
- 他のプログラムの一部として動くもの

それぞれはバイナリクレートととライブラリクレートの関係に似ている。

webassemblyはサンドボックス環境で動作するため、wasmtimeでは利用できるディレクトリを明示的に指定する必要がある。
ディレクトリの他にも、環境変数、ソケット、メモリー空間などが切り離されている。

cargo-componentでプロジェクトを作成しWasmコンポーネントをビルドした。
wasmtimeでWasmコンポーネントを実行した。

## 第4章 他のプログラムから利用されるWasmコンポーネント

ライブラリコンポーネントはインターフェイスをWITで定義する。

- `cargo component new --lib`コマンドでライブラリを生成可能
- パッケージのインターフェイスをWITで定義してからRustで実装する
  - WITファイルから生成されたクレートを実装する。src/bindings.rsに出力される

最初にRustでWebAssemblyのコンポーネントを作成してから、2つの方法でそのコンポーネントを利用した。

### 1つ目: wasmtimeクレートを使う方法

コンポーネントのインスタンスからワールド名や関数名を使ってComponentExportIndexというものを引き出す。
そのComponentExportIndexを使うとインスタンスから関数を引き出せる
関数の.call()メソッドを利用して関数を呼び出す
呼んだあとはpost_return()メソッドを呼び出している

### 2つ目: WITからコード生成を利用する方法
  
wasmtimeクレートのbindgenマクロを利用すると, ラッパークラスが自動生成されて楽に使える。
ワークスペース名とインターフェイス名を"_"で繋げた名前の関数が生成されてそれを使う。

