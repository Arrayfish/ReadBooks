# [予約処理で結果整合を実現するための実装パターン](https://user-first.ikyu.co.jp/entry/2025/12/13/185316)

Sagaパターンを使って予約処理で結果整合を実現する方法について、具体的な実装方法を解説している記事

## 定義

- トランザクション: 予約の処理全体
- ローカルトランザクション: 予約処理を構成する個々の処理
- ロールバック: DBに限らず、ローカルトランザクションの取り消しにも使う。これのために補償トランザクションを使う
- ピボットトランザクション: トランザクション全体の成否決定するローカルトランザクションこと今回は予約のDBへの保存

## 感想

- Sagaパターン [lean.microsoft](https://learn.microsoft.com/en-us/azure/architecture/patterns/saga), [microservice.io](https://microservices.io/patterns/data/saga.html)

### ピボットトランザクション前後のローカルトランザクションを考える

- 前のローカルトランザクションはピボットトランザクションが失敗した時は補償トランザクションでロールバック
- 後のローカルトランザクションはピボットトランザクションが成功した時は最終的に成功している状態にしたい

### 補償ログの導入

- ローカルトランザクションが実行済みであることを記録するログ
- ローカルトランザクションを実行する前に補償ログを記録する, 記録できなかった場合はローカルトランザクションを実行せずに失敗とする
  - ピボットトランザクションが成功した時は補償ログを削除する
  - ピボットトランザクションが失敗した時は補償ログを参照して補償トランザクションを実行するそして補償ログを削除する
- ローカルトランザクションの実行前に補償トランザクションが実行可能な情報が揃っている必要がある。
  - 補償ログには補償トランザクションに必要なIDなどを含める
  - ローカルトランザクションの成功によって補償ログに必要な情報が手に入るような設計はだめ
- 補償ログはピボットトランザクションの成功後に削除する
- 補償トランザクションは冪等にする、以下のような場合に再実行される可能性があるため
  - 補償トランザクション実行に失敗した場合
  - 補償トランザクションに成功した後に、補償ログの削除に失敗した場合

### ピボットトランザクションと「ピボットマーカー」の導入

ピボットトランザクションに対しても、ローカルトランザクションと同様にそれが進行中であることを示すものが必要。
それを「ピボットマーカー」と呼ぶ。

- ピボットマーカーはローカルトランザクションの前に設定する
- ピボットトランザクションとアトミックに削除する(DBに保存するのが楽)
  - ピボットマーカーが存在している -> ピボットトランザクションが完了していない
  - ピボットマーカーが存在していない -> ピボットtランザクションが成功した
- 補償ログとピボットマーカーに親子関係を設ける
  - ピボットマーカーが存在する場合は、実行済みのローカルトランザクションが存在する可能性があr、ロールバックするときはローカルトランザクションに対して補償トランザクションを実行する必要がある。
  - ピボットマーカーが存在しない場合は、トランザクションが成功しているので、ロールバックの必要はない

- 補償トランザクションを実行するときには、常にピボットマーカーを起点に実行する
  - ピボットマーカーが存在しない場合は、トランザクションが成功しているので補償トランザクションを実行しない

そもそも全部が失敗する可能性があるので、実行ができていないものを再実行するものを入れること

## 制約

- ローカルトランザクションを同期的に実行できること
  - ローカルトランザクションの成否がピボットトランザクション実行までに確定していること
- ローカルトランザクション同士が強く結合していないこと
  - 順序制約うがあっても良いが、情報が前段のから後段へ依存しないこと
- トランザクション全体としての一貫性は結果整合で良いこと
  - 予約失敗したときに、一時的にでも在庫の引き当てがだめという制約がある場合は無理

## props

- Sagaパターンなどを意識せずにドメインロジックの実装が可能
- ローカルトランザクションの追加が容易
- ローカルトランザクションの変更が容易
